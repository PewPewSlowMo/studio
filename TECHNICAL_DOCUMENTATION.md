# Техническая документация по приложению CallSync Central

## 1. Введение

**CallSync Central** — это веб-приложение на базе Next.js, предназначенное для мониторинга, управления и аналитики работы колл-центра, интегрированного с **Asterisk PBX**. Приложение предоставляет интерфейсы для операторов, супервизоров и администраторов, каждый из которых имеет свой набор инструментов и отчетов.

### 1.1. Стек технологий

- **Фреймворк:** Next.js (с App Router)
- **Язык:** TypeScript
- **UI:** React, ShadCN UI, Tailwind CSS
- **Управление состоянием:** React Hooks (useState, useEffect, useMemo), без внешних библиотек
- **Работа с формами:** React Hook Form, Zod для валидации
- **Взаимодействие с Asterisk:**
  - **ARI (Asterisk REST Interface):** Для получения данных о состоянии каналов, звонков и операторов в реальном времени.
  - **AMI (Asterisk Manager Interface):** Для выполнения команд (например, получение списка очередей, пользователей) и прослушивания событий.
- **База данных:** MySQL (для хранения Call Detail Records - CDR)
- **Локальное хранилище данных:** JSON-файлы в директории `data/` для хранения пользователей, настроек CRM, обращений и конфигурации.

---

## 2. Архитектура и структура проекта

Приложение построено на современной архитектуре Next.js с использованием серверных компонентов и серверных действий (`Server Actions`) для взаимодействия с бэкендом и внешними сервисами.

### 2.1. Структура директорий

```
/
├── data/                  # Локальная "база данных" в формате JSON
│   ├── appeals.json       # Карточки обращений по звонкам
│   ├── config.json        # Конфигурация подключений (ARI, AMI, CDR)
│   ├── crm.json           # Контакты клиентов
│   └── users.json         # Пользователи системы
│
├── public/                # Статические ассеты (нет в проекте)
│
├── src/
│   ├── actions/           # Серверные действия (бэкенд-логика)
│   │   ├── ami.ts         # Функции для работы с AMI
│   │   ├── appeals.ts     # CRUD для обращений
│   │   ├── ari.ts         # Функции для работы с ARI
│   │   ├── auth.ts        # Логика аутентификации
│   │   ├── cdr.ts         # Функции для работы с БД CDR
│   │   ├── config.ts      # CRUD для файла конфигурации
│   │   ├── crm.ts         # Логика работы с CRM
│   │   └── users.ts       # CRUD для пользователей
│   │
│   ├── app/               # Роутинг и страницы приложения (Next.js App Router)
│   │   ├── admin/         # Страница администратора
│   │   ├── analytics/     # Страница аналитики
│   │   ├── operator/      # Рабочее место оператора
│   │   └── ...            # Другие страницы и layout'ы
│   │
│   ├── components/        # Переиспользуемые UI-компоненты
│   │   ├── admin/         # Компоненты для страницы администратора
│   │   ├── analytics/     # Компоненты для страницы аналитики
│   │   ├── operator/      # Компоненты для рабочего места оператора
│   │   ├── layout/        # Компоненты макета (сайдбар, тема)
│   │   ├── shared/        # Общие компоненты (например, выбор даты)
│   │   └── ui/            # Базовые UI-компоненты (ShadCN)
│   │
│   ├── hooks/             # Пользовательские React-хуки (use-toast, use-mobile)
│   │
│   └── lib/               # Вспомогательные утилиты и типы
│       ├── types.ts       # Определения TypeScript-типов
│       └── utils.ts       # Утилиты (например, `cn` для Tailwind)
│
├── LOCAL_SETUP.md         # Инструкция по локальной установке
├── TECHNICAL_DOCUMENTATION.md # Этот файл
└── ...                    # Конфигурационные файлы (next.config.js, tailwind.config.ts и т.д.)
```

### 2.2. Управление конфигурацией

Ключевой особенностью приложения является отказ от использования `.env` файлов для хранения чувствительных данных (паролей, хостов). Вместо этого используется единый файл `data/config.json`, который редактируется через UI в панели администратора.

- **Преимущества:** Упрощает настройку для нетехнических пользователей, позволяет менять настройки "на лету", не требует перезапуска сервера.
- **Недостатки:** Хранение паролей в открытом виде в JSON-файле. Для production-окружения рекомендуется внедрить шифрование или использовать защищенные хранилища секретов.

### 2.3. Потоки данных и Real-time

Поскольку веб-приложения не могут напрямую поддерживать постоянное TCP-соединение с AMI, для получения данных в реальном времени используется **механизм поллинга (polling)**.

1.  **Состояние операторов и звонков (Дашборд, Панель оператора):**
    -   Клиентский компонент с определенным интервалом (например, каждые 2-3 секунды) вызывает серверное действие `getOperatorState` (`src/actions/ari.ts`).
    -   Это действие отправляет HTTP-запрос к Asterisk REST Interface (ARI) для получения актуального статуса PJSIP-конечной точки (`endpoint`) и связанных с ней каналов.
    -   Данные возвращаются на клиент, где обновляется UI (статус оператора, информация об активном звонке).

2.  **История звонков (Отчеты, Аналитика):**
    -   При загрузке страницы или изменении диапазона дат вызывается серверное действие `getCallHistory` (`src/actions/cdr.ts`).
    -   Это действие устанавливает прямое соединение с MySQL базой данных, выполняет SQL-запрос к таблице `cdr` и возвращает результат.

---

## 3. Детальное описание модулей

### 3.1. Серверные действия (`src/actions`)

Это ядро бэкенд-логики приложения. Все файлы в этой директории содержат директиву `'use server';`.

-   **`ami.ts`**: Использует библиотеку `asterisk-manager` для подключения к AMI. Основные функции:
    -   `runAmiCommand`: Абстракция для выполнения команд, которые возвращают список событий (например, `PJSIPShowEndpoints`).
    -   `runAmiAction`: Абстракция для выполнения команд, возвращающих простой ответ "Success/Error".
    -   `getAmiEndpoints`, `getAmiQueues`: Получение списка конечных точек и очередей.

-   **`ari.ts`**: Взаимодействует с ARI через `fetch`.
    -   `fetchFromAri`: Общая функция для выполнения GET-запросов к ARI с базовой аутентификацией.
    -   `getOperatorState`: **Ключевая функция для real-time мониторинга.** Она выполняет каскад запросов для надежного определения статуса оператора и номера звонящего. Подробная логика описана в `TROUBLESHOOTING.md`.

-   **`cdr.ts`**: Работает с MySQL базой данных истории звонков.
    -   `createCdrConnection`: Создает соединение с базой данных.
    -   `getCallHistory`, `getMissedCalls`: Выполняют SQL-запросы для получения списков звонков с возможностью фильтрации по дате.
    -   `getCallById`: Выполняет "гибкий" поиск звонка по `uniqueid` или `linkedid`, используя `LIKE`, чтобы компенсировать возможные расхождения в ID.

-   **`appeals.ts`, `crm.ts`, `users.ts`, `config.ts`**: Реализуют CRUD-операции для соответствующих JSON-файлов. Они читают файл, парсят JSON, вносят изменения и записывают данные обратно. Используют `revalidatePath` из Next.js для сброса кэша на связанных страницах.

### 3.2. Основные страницы и компоненты

#### 3.2.1. Аутентификация (`/login`)

-   **Страница:** `src/app/login/page.tsx`
-   **Компонент:** `src/components/auth/login-form.tsx`
-   **Логика:**
    1.  Пользователь вводит email и пароль.
    2.  Вызывается серверное действие `loginUser` (`src/actions/auth.ts`).
    3.  Действие находит пользователя в `data/users.json` и проверяет пароль (в виде простого текста).
    4.  В случае успеха объект пользователя (без пароля) сохраняется в `localStorage`.
    5.  `AppLayout` при каждой загрузке страницы проверяет наличие пользователя в `localStorage` и его роль, предоставляя доступ к разрешенным страницам.

#### 3.2.2. Дашборд (`/`)

-   **Страница:** `src/app/page.tsx`
-   **Компоненты:** `kpi-card.tsx`, `call-volume-chart.tsx`, `operator-status.tsx`, `active-calls.tsx`.
-   **Логика:**
    1.  При загрузке страницы `useEffect` выполняет `Promise.all` для получения всех необходимых данных: списка пользователей, эндпоинтов, очередей и истории звонков за последние 24 часа.
    2.  `useMemo` используется для вычисления производных данных (KPI, данные для графиков) при изменении исходных данных.
    3.  Отдельный `useEffect` запускает интервальный опрос состояния операторов (`getOperatorState`) для обновления таблицы "Активные разговоры".
    4.  KPI-карточки показывают агрегированные данные. При наведении на них появляется `Popover` с детальным списком.

#### 3.2.3. Рабочее место оператора (`/operator`)

-   **Страница:** `src/app/operator/page.tsx`
-   **Компоненты:** `caller-info-card.tsx`, `appeal-form.tsx`, `crm-contact-form.tsx`, `follow-up-list.tsx`.
-   **Логика:**
    1.  **Мониторинг статуса:** Главный компонент `operator/page.tsx` непрерывно опрашивает `getOperatorState`, чтобы отслеживать статус оператора.
    2.  **Появление карточки звонка:** Когда статус меняется на `ringing` или `on-call`, `useEffect` триггерит открытие модального окна `CallerInfoCard`.
    3.  **`CallerInfoCard`:** Это центральный компонент, который:
        -   Отображает информацию о звонящем (номер, очередь).
        -   Вызывает `findContactByPhone` для поиска клиента в `crm.json` и отображения его данных или формы создания нового.
        -   Содержит `AppealForm` для заполнения деталей обращения.
    4.  **Режим "Пост-обработка" (`Wrap-up`):** Когда звонок завершается (статус перестает быть `on-call`), включается таймер на 60 секунд. По истечении этого времени форма автоматически сохраняется (если были изменения) и закрывается. Оператор не может закрыть карточку вручную во время активного звонка.
    5.  **Список "Задачи на перезвон":** Компонент `FollowUpList` получает из `appeals.json` все обращения с флагом `followUp: true` и `followUpCompleted: false`. При клике на задачу открывается модальное окно с деталями соответствующего исторического звонка.

#### 3.2.4. Отчеты и аналитика

-   **Страницы:** `/reports`, `/queue-reports`, `/missed-calls`, `/analytics`.
-   **Логика:** Все страницы отчетов работают по схожему принципу.
    1.  Они используют хук `useSearchParams` для считывания диапазона дат из URL.
    2.  `DateRangePicker` (`src/components/shared/date-range-picker.tsx`) позволяет пользователю выбрать период и обновляет URL, что вызывает повторную загрузку данных.
    3.  `useEffect` при изменении `searchParams` вызывает соответствующие серверные действия (`getCallHistory`, `getMissedCalls`) с нужным диапазоном дат.
    4.  Полученные данные обрабатываются в `useMemo` для расчета KPI и подготовки данных для таблиц и графиков.
    5.  Данные передаются в специализированные компоненты таблиц (`operator-report-table.tsx`, `queue-report-table.tsx`) или графиков (`recharts`).

#### 3.2.5. Администрирование (`/admin`)

-   **Страница:** `src/app/admin/page.tsx`
-   **Компоненты:** `user-management.tsx`, `system-settings.tsx`, `user-form-dialog.tsx`.
-   **Логика:**
    1.  **Настройки системы:**
        -   При загрузке страницы `getConfig` читает `data/config.json` и заполняет поля формы.
        -   Кнопки "Тест" вызывают соответствующие серверные действия (`getAsteriskVersion`, `getAmiQueues`, `testCdrConnection`) для проверки введенных данных.
        -   При нажатии "Сохранить" вызывается `saveConfig`, который перезаписывает `data/config.json`.
    2.  **Управление пользователями:**
        -   Отображается список пользователей из `data/users.json`.
        -   При создании/редактировании пользователя открывается `UserFormDialog`.
        -   Для выбора внутреннего номера (`extension`) диалог сначала запрашивает список доступных эндпоинтов через `getAmiEndpoints`.
        -   Сохранение, обновление или удаление пользователя происходит через вызов соответствующих серверных действий из `src/actions/users.ts`.

---
## 4. База данных и хранилище

### 4.1. MySQL (CDR)

-   **Таблица:** `cdr`
-   **Назначение:** Хранение детальной информации о каждом завершенном звонке. Это основной источник данных для всех исторических отчетов.
-   **Ключевые поля:**
    -   `calldate`: Дата и время звонка.
    -   `src`: Номер звонящего.
    -   `dst`: Номер назначения.
    -   `dcontext`: Контекст вызова (используется для определения очереди).
    -   `disposition`: Финальный статус звонка ('ANSWERED', 'NO ANSWER', 'BUSY').
    -   `uniqueid`, `linkedid`: Уникальные идентификаторы звонка.
    -   `duration`: Общая длительность канала.
    -   `billsec`: Длительность разговора (после ответа).
    -   `userfield`: Поле для пользовательских данных (планируется для хранения оценки удовлетворенности).

### 4.2. JSON-файлы

-   Используются как простая файловая база данных для сущностей, не требующих сложных реляционных связей.
-   **Преимущество:** Легко редактировать вручную, не требует настройки отдельной СУБД.
-   **Недостаток:** Не масштабируется. При большом количестве записей (особенно в `appeals.json`) операции чтения/записи могут замедляться. Для production-системы рекомендуется миграция на полноценную СУБД (например, PostgreSQL или MySQL).
